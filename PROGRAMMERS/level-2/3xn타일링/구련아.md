너무너무 어려웠다.

우선 아래처럼 생각었는데 점화식이 세워지지도 않고, n이 10인 경우부터는 도저히 구할 수가 없었다. 결국 인터넷에서 푸는 법을 찾았다.

```js
dp[2] = 3;
dp[4] = 3 * 3 + 2; // 11
dp[6] = 3 * 3 * 3 + 3 * 2 * 2 + 2; // 27 + 12 + 2 → 27 + 14
dp[8] = 3 * 3 * 3 * 3 + 2 * 2 + 2 * 3 * 3 * 3 + 14;
```

그런데 검색해서 찾은 점화식대로 실행해도 절반 이상이 틀렸다고 나왔다. n이 최댓값인 5000일 때는 값이 제대로 나왔기 때문에 점화식이 아니라 나머지 계산이 문제라고 생각했다.
원인은 나머지 값을 구한 다음에 뺄 때 발생한 문제였다. 나머지 값을 각각 구해 뺄 때 항상 양수가 나오지 않을 수가 있다. 아래처럼 `(A % MOD)`가 `(B % MOD)`보다 항상 크다는 보장이 없다. 이런 경우를 한 번도 고려한 적이 없어서 좋은 문제였던 것 같다.

```js
((A % MOD) - (B % MOD)) % MOD; // 항상 양수라는 보장이 없다
```

문제가 어려워서인지 당연해서인지 n이 홀수인 경우를 채점하는 경우는 없었다. n이 홀수일 때 값이 0이 맞는지 확인하려고 했는데 모두 틀렸다고 나오길래 잘못 생각했나 고민했다. 좀더 확신을 가져야겠다.
